:var: {nbsp}{nbsp}{nbsp}{nbsp}
:attr: {var}{var}
[%autowidth,options="header",]
|===
|Description |Obligation |Comment
e|Group attributes | |
 |{attr}:beam_mode |M |Mode of the beam in this subgroup, taken from the defined vocabulary of: “vertical” (a set of beams that form a vertical slice through the water), ”horizontal” (a set of beams that form a nominally horizontal plane through the water), and ”inspection” (a set of beams with arbitrary pointing directions).
 |{attr}conversion_equation_t :conversion_equation_type |M |Type of equation used to convert backscatter measurements into volume backscattering strength and target strength.
 |{attr}int :preferred_MRU |MA |Index of the MRU sensor to use by default. If the sensor used can be dynamically changed, refer to the variable active_MRU. Index matches the ones used in the Platform MRU sensors variables.
 |{attr}int :preferred_position |MA |Index of the position sensor to use by default. If the sensor used can be dynamically changed, refer to the variable active_position_sensor. Index matches the ones used in the Platform position sensors variables.

e|Dimensions | |
 |{var}beam | |The number of beams in this beam group.
 |{var}subbeam | |The number of sub-beams in these beams
 |{var}ping_time = unlimited | |Can be of fixed or unlimited length, as appropriate.
 |{var}tx_beam | |The number of transmit beams in this beam group
 
e|Coordinate variables | |
 |{var}string beam(beam) |M |Beam name (or number or identification code).
 3+|{attr}:long_name = "Beam name" 

 |{var}uint64 ping_time(ping_time) |M |Timestamp at which each ping occurred.
 3+|{attr}:axis = "T" 
 3+|{attr}:calendar = "gregorian" 
 3+|{attr}:long_name = "Time-stamp of each ping" 
 3+|{attr}:standard_name = "time" 
 3+|{attr}:units = "nanoseconds since 1601-01-01 00:00:00Z" 
 
e|Variables | |
 |{var}sample_t backscatter_i(ping_time, beam, subbeam) |MA |Imaginary part of backscatter measurements. Each element in the 3D matrix is a variable length vector (of type sample_t) that contains the samples for that beam, ping time, and optionally subbeam.
 3+|{attr}:long_name = "Raw backscatter measurements (imaginary part)" 
 |{attr}:units = "as appropriate" | |Use units appropriate for the data.

 |{var}sample_t backscatter_r(ping_time, beam, subbeam) |M |Real part or amplitude or power of backscatter measurements. Each element in the 3D matrix is a variable length vector (of type sample_t) that contains the samples for that beam, ping time, and optionally subbeam.
 3+|{attr}:long_name = "Raw backscatter measurements (real part)" 
 |{attr}:units = "as appropriate" | |Use units appropriate for the data.

 |{var}angle_t echoangle_major(ping_time, beam) |MA |Electrical phase angle of the incoming echoes at time ping_time relative to the direction of each beam. Only required if the beam_type variable for this ping_time is set to split_aperture_angles.
 3+|{attr}:long_name = "Echo arrival angle in the major beam coordinate"
 3+|{attr}:units = "arc_degree"
 3+|{attr}float :valid_range = -180.0, 180.0

 |{var}angle_t echoangle_minor(ping_time, beam) |MA |Electrical phase angle of the incoming echoes at time ping_time relative to the direction of each beam. Only required if the beam_type variable for this ping_time is set to split_aperture_angles.
 3+|{attr}:long_name = "Echo arrival angle in the minor beam coordinate"
 3+|{attr}:units = "arc_degree"
 3+|{attr}float :valid_range = -180.0, 180.0
 
 |{var}float echoangle_major_sensitivity(beam) |MA |Scaling factor to convert electrical arrival angles into physical angles. Only required if beam_type is not set to single.
 3+|{attr}:long_name = "Major angle scaling factor"
 3+|{attr}:units = "1"
 3+|{attr}float :valid_min = 0.0

 |{var}float echoangle_minor_sensitivity(beam) |MA |Scaling factor to convert electrical arrival angles into physical angles. Only required if beam_type is not set to single.
 3+|{attr}:long_name = "Minor angle scaling factor"
 3+|{attr}:units = "1"
 3+|{attr}float :valid_min = 0.0

 |{var}float beamwidth_receive_major(ping_time, beam) |M |One-way beam width at half power down in the horizontal direction of the receive beam.
 3+|{attr}:long_name = "Half power one-way receive beam width along major (horizontal) axis of beam" 
 3+|{attr}:units = "arc_degree"
 3+|{attr}float :valid_range = 0.0, 360.0 

 |{var}float beamwidth_receive_minor(ping_time, beam) |M |One-way beam width at half power down in the vertical direction of the receive beam.
 3+|{attr}:long_name = "Half power one-way receive beam width along minor (vertical) axis of beam"
 3+|{attr}:units = "arc_degree" 
 3+|{attr}float :valid_range = 0.0, 360.0 

 |{var}float beamwidth_transmit_major(ping_time, tx_beam) |MA |One-way beam width at half power down in the horizontal direction of the transmit beam.
 3+|{attr}:long_name = "Half power one-way transmit beam width along major (horizontal) axis of beam"
 3+|{attr}:units = "arc_degree" 
 3+|{attr}float :valid_range = 0.0, 360.0 

 |{var}float beamwidth_transmit_minor(ping_time, tx_beam) |MA |One-way beam width at half power down in the vertical direction of the transmit beam.
 3+|{attr}:long_name = "Half power one-way transmit beam width along minor (vertical) axis of beam"
 3+|{attr}:units = "arc_degree" 
 3+|{attr}float :valid_range = 0.0, 360.0 

 |{var}float rx_beam_rotation_alpha(ping_time, beam) |M |The extrinsic z-x-z clockwise rotation about the _z_-axis of the platform coordinate system needed to give the beam coordinate system.
 3+|{attr}:long_name = "angular rotation about the _z_ axis"
 3+|{attr}:units = "arc_degree" 
 3+|{attr}float :valid_range = −180.0, 180.0 

 |{var}float rx_beam_rotation_beta(ping_time, beam) |M |The extrinsic z-x-z clockwise rotation about the _x_-axis of the platform coordinate system needed to give the beam coordinate system.
 3+|{attr}:long_name = "angular rotation about the _x_ axis"
 3+|{attr}:units = "arc_degree" 
 3+|{attr}float :valid_range = −180.0, 180.0 

 |{var}float rx_beam_rotation_gamma(ping_time, beam) |M |The extrinsic z-x-z clockwise rotation about the _z_-axis of the platform coordinate system needed to give the beam coordinate system.
 3+|{attr}:long_name = "angular rotation about the _z_ axis"
 3+|{attr}:units = "arc_degree" 
 3+|{attr}float :valid_range = −180.0, 180.0 

 |{var}float tx_beam_direction_x(ping_time, tx_beam) |M |The _x_-axis coordinate of a unit vector in the beam direction for each tx_beam and ping, as per the sonar beam coordinate system.
 3+|{attr}:long_name = "_x_-component of the vector that gives the pointing direction of the tx_beam, in sonar beam coordinate system"
 3+|{attr}:units = "1"
 3+|{attr}float :valid_range = −1.0, 1.0 

 |{var}float tx_beam_direction_y(ping_time, tx_beam) |M |The _y_-axis coordinate of a unit vector in the tx_beam direction for each beam and ping, as per the sonar beam coordinate system.
 3+|{attr}:long_name = "_y_-component of the vector that gives the pointing direction of the tx_beam, in sonar beam coordinate system"
 3+|{attr}:units = "1" 
 3+|{attr}float :valid_range = −1.0, 1.0 

 |{var}float tx_beam_direction_z(ping_time, tx_beam) |M |The _z_-axis coordinate of a unit vector in the tx_beam direction for each beam and ping, as per the sonar beam coordinate system.
 3+|{attr}:long_name = "_z_-component of the vector that gives the pointing direction of the tx_beam, in sonar beam coordinate system"
 3+|{attr}:units = "1"
 3+|{attr}float :valid_range = −1.0, 1.0 

 |{var}beam_stabilisation_t beam_stabilisation(ping_time) |M |Indicates whether or not sonar beams have been compensated for platform motion.
 3+|{attr}:long_name = "Beam stabilisation applied (or not)" 

 |{var}beam_t beam_type |M |Type of split-aperture beam (or not).
 3+|{attr}:long_name = "Type of beam"

 |{var}float equivalent_beam_angle(ping_time, beam) |M |Equivalent beam angle.
 3+|{attr}:long_name = "Equivalent beam angle" 
 3+|{attr}:units = "sr" 
 2+|{attr}float :valid_range = 0.0, 12.56637061435917295385 | Maximum value is equivalent to 4π.

 |{var}float gain_correction(ping_time, beam) |MA |Gain correction. This parameter is set from a calibration exercise. Necessary for type 2 conversion equation.
 3+|{attr}:long_name = "Gain correction" 
 3+|{attr}:units = "dB" 

 |{var}short non_quantitative_processing(ping_time) |M |Settings of any processing that is applied prior to recording backscatter data that may prevent the calculation of calibrated backscatter. A value of 0 always indicates no such processing.
 |{attr}:flag_meanings | |Space-separated list of non-quantitative processing setting words or phrases. The first item must always be the no non-quantitative processing setting and subsequent items as appropriate to the sonar and data(e.g. ”no_non_quantitative_processing simrad_noise_filter_weak simrad_noise_filter_medium simrad_noise_filter_strong”).
 |{attr}short :flag_values | |List of unique values (e.g. 0, 1, 3, 4) that indicate different non-quantitative processing settings that could be present in the sonar data. Must have the same number of values as settings given in the flag_meanings attribute.
 3+|{attr}:long_name = "Presence or not of non-quantitative processing applied to the backscattering data (sonar specific)" 

 |{var}float receiver_sensitivity(ping_time, beam) |MA |Sensitivity of the sonar receiver for the current ping. Necessary for type 2 conversion equation.
 3+|{attr}:long_name = "Receiver sensitivity" 
 3+|{attr}:units = "dB re 1/μ" 
 
 |{var}float sample_interval(ping_time) |M |Time between individual samples along a beam. Common for all beams in a ping.
 3+|{attr}:long_name = "Interval between recorded raw data samples" 
 3+|{attr}:units = "s" 
 3+|{attr}float :valid_min = 0.0 

 |{var}float sample_time_offset(ping_time, tx_beam) |M |Time offset applied to sample time-stamps and intended for applying a range correction (e.g. as caused by signal processing delays). Positive values reduce the calculated range to a sample. The range of a given sample at index sample_index and if a constant sound speed is applied is given by range= sound_speed_at_transducer*(blanking_interval+sample_index*sample_interval - sample_time_offset)/2
 3+|{attr}:long_name = "Time offset that is subtracted from the timestamp of each sample" 
 3+|{attr}:units = "s" 
 
 |{var}float sa_correction(ping_time, tx_beam) |MA| XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 3+|{attr}:long_name = ""
 3+|{attr}:units = ""
 
 |{var}float blanking_interval(ping_time, beam) |M |Amount of time during reception where samples are discarded. The number of discarded sample is given by blanking_interval*sample_interval.
 3+|{attr}:long_name = "Amount of time during reception where samples are discarded" 
 3+|{attr}:units = "s" 
 3+|{attr}:valid_min = "0.0" 
 
 |{var}sample_t time_varied_gain(ping_time) |MA |Time-varied gain (TVG) used for each ping. Should contain TVG coefficient vectors. Necessary for type 2 conversion equations.
 3+|{attr}:long_name = "Time-varied-gain coefficients" 
 3+|{attr}:units = "dB" 
 
 |{var}float transducer_gain(ping_time, beam) |MA |Gain of the transducer beam. This is the parameter that is set from a calibration exercise. Necessary for conversion equation type 1.
 3+|{attr}:long_name = "Gain of transducer" 
 3+|{attr}:units = "dB" 
 
 |{var}float transmit_bandwidth(ping_time, tx_beam) |O |Estimated bandwidth of the transmitted pulse. For CW pulses, this is a function of the pulse duration and frequency. For FM pulses, this will be close to the difference between transmit_frequency_start and transmit_frequency_stop.
 3+|{attr}:long_name = "Nominal bandwidth of transmitted pulse" 
 3+|{attr}:units = "Hz" 
 3+|{attr}float :valid_min = 0.0 
 
 |{var}float transmit_duration_equivalent(ping_time, tx_beam) |MA |Equivalent duration of the transmit pulse. This is the square pulse containing the same energy as the actual transmitted pulse. Necessary for both type 1 and 2 conversion equations.
 3+|{attr}:long_name = "Equivalent duration of transmitted pulse" 
 3+|{attr}:units = "s" 
 3+|{attr}float :valid_min = 0.0 
 
 |{var}float transmit_duration_nominal(ping_time, tx_beam) |M |Nominal duration of the transmit pulse. This is not the equivalent pulse duration.
 3+|{attr}:long_name = "Nominal duration of transmitted pulse" 
 3+|{attr}:units = "s" 
 3+|{attr}float :valid_min = 0.0 
 
 |{var}float transmit_frequency_start(ping_time, tx_beam) |M |Frequency at the start of the transmit pulse. The beam dimension can be omitted, in which case the value apples to all beams in the ping.
 3+|{attr}:long_name = "Start frequency in transmitted pulse" 
 3+|{attr}:standard_name = "sound_frequency" 
 3+|{attr}:units = "Hz" 
 3+|{attr}float :valid_min = 0.0 
 
 |{var}float transmit_frequency_stop(ping_time, tx_beam) |M |Frequency at the end of the transmit pulse. The beam dimension can be omitted, in which case the value apples to all beams in the ping.
 3+|{attr}:long_name = "Stop frequency in transmitted pulse" 
 3+|{attr}:standard_name = "sound_frequency" 
 3+|{attr}:units = "Hz" 
 3+|{attr}float :valid_min = 0.0 
 
 |{var}float transmit_power(ping_time, tx_beam) |MA |Electrical transmit power used for the ping. Necessary for type 1 conversion equations
 3+|{attr}:long_name = "Nominal transmit power" 
 3+|{attr}:units = "W" 
 3+|{attr}float :valid_min = 0.0 
 
 |{var}float transmit_source_level(ping_time, tx_beam) |MA |Source level generated by the transmit ping. Necessary for type 2 conversion equations.
 3+|{attr}:long_name = "Transmit source level" 
 3+|{attr}:units = "dB re 1 μPa at 1m" 
 
 |{var}transmit_t transmit_type(ping_time) |M |Type of transmit pulse.
 3+|{attr}:long_name = "Type of transmitted pulse" 
 
 |{var}int receive_transducer_index(beam) |MA |Receiving or monostatic transducer index associated with the given beam
 3+|{attr}:valid_min = "0" 
 3+|{attr}:long_name = "Receive transducer index" 
 
 |{var}int active_MRU(ping_time) |MA |Indicate the index of the MRU sensor used at the time of the ping to compute the platform attitude.
 3+|{attr}:valid_min = "0" 
 3+|{attr}:long_name = "Active MRU sensor index" 
 
 |{var}int active_position_sensor(ping_time) |MA |Indicate the index of the position sensor used at the time of the ping to compute the platform position.
 3+|{attr}:valid_min = "0"
 3+|{attr}:long_name = "Active position sensor index" 
 
 |{var}float sound_speed_at_transducer(ping_time) |O |Sound speed at transducer depth at the time of the ping
 3+|{attr}:long_name = "Indicative sound speed at ping time and transducer depth" 
 3+|{attr}:units = "m/s" 
 3+|{attr}float :valid_min = 0.0 
 3+|{attr}:standard_name = "speed_of_sound_in_sea_water" 
 
 |{var}double platform_latitude(ping_time) |M |Latitude of the platform reference point in WGS-84 reference system at the time of the ping.
 3+|{attr}double :valid_range = −90.0, 90.0 
 3+|{attr}:standard_name = "Platform latitude" 
 3+|{attr}:units = "degrees_north"
 3+|{attr}:long_name = "latitude" 
 3+|{attr}double :_FillValue = Double.NaN 
 
 |{var}double platform_longitude(ping_time) |M |Longitude of the platform reference point in WGS-84 reference system at the time of the ping.
 3+|{attr}double :valid_range = −180.0, 180.0 
 3+|{attr}:standard_name = "Platform longitude" 
 3+|{attr}:units = "degrees_east" 
 3+|{attr}:long_name = "longitude" 
 3+|{attr}double :_FillValue = Double.NaN 
 
 |{var}float platform_heading(ping_time) |M |Heading of the platform at time of the ping.
 3+|{attr}:standard_name = "platform_orientation" 
 3+|{attr}:units = "degrees_north" 
 3+|{attr}:long_name = "Platform heading(true)" 
 3+|{attr}float :valid_range = 0, 360.0 
 
 |{var}float platform_pitch(ping_time) |M |Platform pitch at the time of the ping.
 3+|{attr}:crs = "VCS" 
 3+|{attr}:standard_name = "platform_pitch_angle" 
 3+|{attr}:units = "arc_degree" 
 3+|{attr}:long_name = "pitch angle" 
 3+|{attr}float :valid_range = −90.0, 90.0 
 
 |{var}float platform_roll(ping_time) |M |Platform roll at the time of the ping.
 3+|{attr}:crs = "VCS" 
 3+|{attr}:standard_name = "platform_roll_angle" 
 3+|{attr}:units = "arc_degree" 
 3+|{attr}:long_name = "roll angle" 
 
 |{var}float platform_vertical_offset(ping_time) |M |Distance from the platform reference point to the water line (distance are positives downwards). For ships and similar, this is called heave, but the concept applies equally well to underwater vehicle depth.
 3+|{attr}:long_name = "Platform vertical distance from reference point to the water line" 
 3+|{attr}:units = "m" 
 
 |{var}float tx_transducer_depth(ping_time) |O |Tx transducer depth below waterline at time of the ping (distance are positives downwards). This variable can be recomputed in most cases by applying lever arm and rotation matrix taking into account for roll and pitch, platform_vertical_offset but can also take into account for drop keel position
 3+|{attr}:long_name = "Tx transducer depth below waterline" 
 3+|{attr}:units = "m" 
 
 |{var}float waterline_to_chart_datum(ping_time) |O |Vertical translation vector at the time of the ping matching the distance from the water line to the chart data reference (typically Lowest Astronomical Tide or Mean Sea Level). This variable is the vector obtains by adding the tide, the dynamic draught at the time of the ping and allow to position samples in an absolute referential.
 3+|{attr}:long_name = "vertical translation from waterline to chart datum reference " 
 3+|{attr}:units = "m" 
 2+|{attr}:vertical_coordinate_reference_system = "MSL depth" |The vertical datum to which distance are referred to. Possible values are 'MSL Depth' or 'LAT Depth'
|===
